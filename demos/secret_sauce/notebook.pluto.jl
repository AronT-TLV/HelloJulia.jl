### A Pluto.jl notebook ###
# v0.16.0

using Markdown
using InteractiveUtils

# ╔═╡ f6b2d3ed-0205-44aa-9bca-7c69b794f8ce
md"# Brief sketch of Julia's secret sauce"

# ╔═╡ b7ef88da-2f7e-4412-b795-033f6f2a0674
md"""
To launch a live version of this notebook follow [these
instructions](https://github.com/ablaom/HelloJulia.jl/blob/dev/NOTEBOOKS.md).
"""

# ╔═╡ 2d95e9db-a2b9-48b6-935f-ddf6a6bfbbdd
md"Julia's *secret sauce:*"

# ╔═╡ 9d38b890-85c6-4768-af2a-25235e544a31
md"""
- **Just-in-time compilation**
- **Multiple dispatch**
- **Abstract types**
"""

# ╔═╡ 49d7d413-b98b-4d58-8af5-148d95ea2900
md"The following is not needed if running from the REPL:"

# ╔═╡ ce65b4a9-5381-42b4-a6bf-47194d7e8e12
begin
  using Pkg
  Pkg.activate(temp=true)
  Pkg.add("InteractiveUtils")
  using InteractiveUtils
end

# ╔═╡ b479e9f2-7327-4fac-828a-4cc485149963
md"## Just-in-time compilation"

# ╔═╡ f5dc834c-8820-465e-9e54-3f7b3ca87ecb
md"Here's how we define a new function in Julia:"

# ╔═╡ 848bb6b9-4d18-4cb6-ba1f-6363f43ec697
add(x, y) = x + y

# ╔═╡ ec385e2c-f9e4-4990-95ea-2955abd45275
md"Let's see how long it takes to add two numbers:"

# ╔═╡ ea340fab-cb94-4396-b1b3-dd47e367ba54
@time @eval add(3, 5)

# ╔═╡ 7d473844-ea0a-4586-8d7e-8e449afd1c48
md"""
Slow!! Why? Because Julia is a *compiled* language and does not
compile new code until it knows the type of arguments you want to
use. (The use of the macro `@eval` helps us to include this
compilation time in the total measurement, since `@time` is designed
to cleverly exclude it in recent Julia versions.)
"""

# ╔═╡ cfc68404-2fcf-4e95-a949-7f3bd292fe31
md"Let's try again *with the same type* of argument:"

# ╔═╡ 8f285628-3b0a-4ed6-8514-99938a2932db
@time @eval add(4, 7)

# ╔═╡ 90354dfd-148c-4590-a0de-1721c1bc2df2
md"""
Fast!!! Why? Because Julia caches the compiled code and the types
are the same. We can even inpsect an annotated version of this
compiled code:
"""

# ╔═╡ bfc1b998-468b-45e6-bca8-7eec7950fd82
@code_llvm add(4, 7)

# ╔═╡ c248989e-503c-49ed-9873-1b1430e635cc
md"""
This code is indistinguishable from that generated by the clang C
compiler.
"""

# ╔═╡ 0069f5ef-21f3-4362-b43e-d0ebe87da176
md"Let's try complex numbers:"

# ╔═╡ 82f2c861-e086-43c5-9009-4cfb2012998f
@time @eval add(1 + 2im, 4 + 3im)

# ╔═╡ 3d947de5-b6a3-4f8f-abd3-cb77d7a79683
md"Slow :-("

# ╔═╡ 675adaac-66e9-4ea4-879e-dc128f3db7b3
@time @eval add(3 + 6im, 7 - 5im)

# ╔═╡ 97317766-2964-4bda-a367-9aa3c6cf34d0
md"Fast :-)."

# ╔═╡ 6be383da-149a-46ee-bf32-94657e65284e
md"Just-in-time compilation exists in other languages (eg, Java)."

# ╔═╡ b502f6a1-bc47-4a24-9afd-65a5b5facac9
md"## Multiple dispatch"

# ╔═╡ b6dd9999-eba6-4c36-b6c8-54f5ed90a964
y = [1 2; 3 4]

# ╔═╡ 81d7898d-7e0d-4558-9292-fe822525fc77
typeof(y)

# ╔═╡ e0722c56-bab2-4586-ae5e-4b83dcbc9675
md"""
Julia doesn't know how to apply `+` to a scalar and a
matrix. Uncomment the following line to see the error thrown:
"""

# ╔═╡ 0c9aae1a-0861-4e8c-8a29-32f11452654a
# add(4, y)

# ╔═╡ 9e999f31-7659-4d0d-a5f1-151fcbe229a2
md"""
So we add a more specialized version of our function (called a
*method*) to handle this case:
"""

# ╔═╡ 658f9270-5eca-415b-81bc-2d5603785a09
add(x::Int, y::Array{Int,2}) = x .+ y

# ╔═╡ 8a59bfae-158d-4632-9d87-1d1fbb0e3997
md"""
Here we are using the built-in broadcasted version of `+` which adds
the scalar `x` to each element of `y`. Now this works:
"""

# ╔═╡ 0b64f309-47bf-4a30-b950-fddef2a1fb10
add(4, y)

# ╔═╡ 0fcf0345-8ccd-4ae8-951b-64cb2a36c8e3
md"""
This is essentially what multiple dispatch is about. We use *all*
the arguments of a function to determine what specific method to
call. In a traditional object oriented language methods are owned by
objects (data structures) and we see syntax like `x.add(y)` which is
*single* dispatch on `x`.
"""

# ╔═╡ 1fb4c0ce-f140-408a-b0e6-441461cc8770
md"""
Multiple dispatch is not used in any widely used languages. Dylan is
the most well-known example.
"""

# ╔═╡ fee6b15a-0c87-497b-8cb0-de601961bc02
md"""
If you are coming from a traditional object oriented language like
Python, then you're used to thinking of objects "owning" methods. In
Julia *functions*, not objects, own *methods*:
"""

# ╔═╡ 4a0d9a26-63d1-4e9c-a87d-950c50fb2955
methods(add)

# ╔═╡ ab84efb1-244a-4545-8448-4bcb089096cd
md"""
Or, stated differently, there is less conflation of *structure* and
*behaviour* in Julia!
"""

# ╔═╡ 87323275-2318-4587-a012-a84240254fb6
md"""
But, we're not out of the woods yet. Uncomment to see a new error
thrown:
"""

# ╔═╡ a2c9884f-021d-4b58-bbdd-9799f7bb2e60
# add(4.0, y)

# ╔═╡ 61e9eb8d-7c51-46cc-97a7-88e3af4f10ee
md"""
Oh dear. Do we need to write a special method for every kind of
scalar and matrix???!
"""

# ╔═╡ 3645fdc2-5739-4cb0-b372-8c9866e51852
md"No, because abstract types come to the rescue..."

# ╔═╡ 0553da4d-58d7-4d4c-8f3d-b82f1e7b6f7a
md"## Abstract types"

# ╔═╡ 87fecfb3-8c1e-4d22-ab04-579e5608ae53
md"Everything in Julia has a type:"

# ╔═╡ 58047fc3-2773-4979-86cf-35420d9e6995
typeof(1 + 2im)

# ╔═╡ e38e2f65-cc4e-49b8-a29a-8d0445351914
typeof(rand(2,3))

# ╔═╡ 6674ce39-d112-4307-be65-28d0fcca50a8
md"""
These are examples of *concrete* types. But concrete types have
*supertypes*, which are *abstract*:
"""

# ╔═╡ f00a74c6-f29b-4fd5-9a2e-c468345d87d1
supertype(Int)

# ╔═╡ 37b26b0a-ece2-45f3-b5fa-cb79ebf595ef
supertype(Signed)

# ╔═╡ f602d1f0-c159-42c3-91c5-524da38aa391
supertype(Integer)

# ╔═╡ d550f1fc-fd5d-48ec-ad90-b4405b216771
md"And we can travel in the other direction:"

# ╔═╡ 22deab2f-1ec6-451e-895b-997a92b731e0
subtypes(Real)

# ╔═╡ 18f26303-e83f-45c3-a525-e9b04a4bd246
4 isa Real

# ╔═╡ 0be288d9-2ae2-49db-80f0-ba7781e173cf
Bool <: Integer

# ╔═╡ 26b59f93-6cf1-4e7c-9cbc-9a2c39793333
String <: Integer

# ╔═╡ 2ff4abaa-f1fb-4981-b887-2b16710e5502
md"""
Now we can solve our problem: How to extend our `add` function to
arbitrary scalars and matrices:
"""

# ╔═╡ 43f8f733-eb9b-412d-9452-5298a8a4a401
add(x::Real, y::Matrix) = x .+ y

# ╔═╡ b6b617cc-bbb7-4235-b017-96f1602f2cad
add(4.0, rand(Bool, 2, 3))

# ╔═╡ 65028960-b00a-4216-8be2-2a4017c45345
md"""
Note that abstract types have no instances. The only "information"
in an abstract type is what its supertype and subtypes
are. Collectively, abstract types and concrete types constitute a
tree structure, with the concrete types as leaves. This structure
exists to *organize* the concrete types in a way that facilitates
extension of functionality. This tree is not static, but can be
extended by the programmer.
"""

# ╔═╡ 135dac9b-0bd9-4e1d-a7ad-80d84f5b0070
md"""
---

*This notebook was generated using [Literate.jl](https://github.com/fredrikekre/Literate.jl).*
"""

# ╔═╡ Cell order:
# ╟─f6b2d3ed-0205-44aa-9bca-7c69b794f8ce
# ╟─b7ef88da-2f7e-4412-b795-033f6f2a0674
# ╟─2d95e9db-a2b9-48b6-935f-ddf6a6bfbbdd
# ╟─9d38b890-85c6-4768-af2a-25235e544a31
# ╟─49d7d413-b98b-4d58-8af5-148d95ea2900
# ╠═ce65b4a9-5381-42b4-a6bf-47194d7e8e12
# ╟─b479e9f2-7327-4fac-828a-4cc485149963
# ╟─f5dc834c-8820-465e-9e54-3f7b3ca87ecb
# ╠═848bb6b9-4d18-4cb6-ba1f-6363f43ec697
# ╟─ec385e2c-f9e4-4990-95ea-2955abd45275
# ╠═ea340fab-cb94-4396-b1b3-dd47e367ba54
# ╟─7d473844-ea0a-4586-8d7e-8e449afd1c48
# ╟─cfc68404-2fcf-4e95-a949-7f3bd292fe31
# ╠═8f285628-3b0a-4ed6-8514-99938a2932db
# ╟─90354dfd-148c-4590-a0de-1721c1bc2df2
# ╠═bfc1b998-468b-45e6-bca8-7eec7950fd82
# ╟─c248989e-503c-49ed-9873-1b1430e635cc
# ╟─0069f5ef-21f3-4362-b43e-d0ebe87da176
# ╠═82f2c861-e086-43c5-9009-4cfb2012998f
# ╟─3d947de5-b6a3-4f8f-abd3-cb77d7a79683
# ╠═675adaac-66e9-4ea4-879e-dc128f3db7b3
# ╟─97317766-2964-4bda-a367-9aa3c6cf34d0
# ╟─6be383da-149a-46ee-bf32-94657e65284e
# ╟─b502f6a1-bc47-4a24-9afd-65a5b5facac9
# ╠═b6dd9999-eba6-4c36-b6c8-54f5ed90a964
# ╠═81d7898d-7e0d-4558-9292-fe822525fc77
# ╟─e0722c56-bab2-4586-ae5e-4b83dcbc9675
# ╠═0c9aae1a-0861-4e8c-8a29-32f11452654a
# ╟─9e999f31-7659-4d0d-a5f1-151fcbe229a2
# ╠═658f9270-5eca-415b-81bc-2d5603785a09
# ╟─8a59bfae-158d-4632-9d87-1d1fbb0e3997
# ╠═0b64f309-47bf-4a30-b950-fddef2a1fb10
# ╟─0fcf0345-8ccd-4ae8-951b-64cb2a36c8e3
# ╟─1fb4c0ce-f140-408a-b0e6-441461cc8770
# ╟─fee6b15a-0c87-497b-8cb0-de601961bc02
# ╠═4a0d9a26-63d1-4e9c-a87d-950c50fb2955
# ╟─ab84efb1-244a-4545-8448-4bcb089096cd
# ╟─87323275-2318-4587-a012-a84240254fb6
# ╠═a2c9884f-021d-4b58-bbdd-9799f7bb2e60
# ╟─61e9eb8d-7c51-46cc-97a7-88e3af4f10ee
# ╟─3645fdc2-5739-4cb0-b372-8c9866e51852
# ╟─0553da4d-58d7-4d4c-8f3d-b82f1e7b6f7a
# ╟─87fecfb3-8c1e-4d22-ab04-579e5608ae53
# ╠═58047fc3-2773-4979-86cf-35420d9e6995
# ╠═e38e2f65-cc4e-49b8-a29a-8d0445351914
# ╟─6674ce39-d112-4307-be65-28d0fcca50a8
# ╠═f00a74c6-f29b-4fd5-9a2e-c468345d87d1
# ╠═37b26b0a-ece2-45f3-b5fa-cb79ebf595ef
# ╠═f602d1f0-c159-42c3-91c5-524da38aa391
# ╟─d550f1fc-fd5d-48ec-ad90-b4405b216771
# ╠═22deab2f-1ec6-451e-895b-997a92b731e0
# ╠═18f26303-e83f-45c3-a525-e9b04a4bd246
# ╠═0be288d9-2ae2-49db-80f0-ba7781e173cf
# ╠═26b59f93-6cf1-4e7c-9cbc-9a2c39793333
# ╟─2ff4abaa-f1fb-4981-b887-2b16710e5502
# ╠═43f8f733-eb9b-412d-9452-5298a8a4a401
# ╠═b6b617cc-bbb7-4235-b017-96f1602f2cad
# ╟─65028960-b00a-4216-8be2-2a4017c45345
# ╟─135dac9b-0bd9-4e1d-a7ad-80d84f5b0070
